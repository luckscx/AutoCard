# 核心编码框架设计

## 一、设计目标

1. **抽象复杂内容**：把卡牌效果、Kind、目标规则、品阶等从散落逻辑中抽成可配置、可扩展的体系。
2. **降低扩展成本**：新增效果、Kind、卡牌、战斗规则时，以 **配置 + 单一处理点** 为主，尽量少改核心循环。
3. **与客户端解耦**：战斗引擎只输出 **结构化事件与状态快照**，不包含任何 UI、资源路径、动画名；客户端通过 **事件类型 + 载荷** 自行映射到表现。

---

## 二、整体分层

```
┌─────────────────────────────────────────────────────────────┐
│  配置层 (Config)                                             │
│  Tiers / Kinds / PortTypes / Items / Monsters / Events       │
│  纯数据，可 JSON 或 TS 常量，支持热更/多语言 key               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  注册层 (Registry)                                            │
│  EffectRegistry: portType → EffectHandler                    │
│  TargetResolver: targetRule + board → 目标槽位/角色           │
│  KindPassiveRegistry (可选): kind 条件 → 被动修正函数          │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  战斗引擎 (Battle Engine)                                     │
│  纯逻辑：Tick 推进、充能、触发端口、应用效果、DoT、胜负判定       │
│  输入：Combatant × 2 + 战斗参数                                │
│  输出：BattleResult + BattleEvent[] + BattleSnapshot[]        │
│  不依赖 UI、不引用具体效果实现，只调 Registry 的 handler        │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  表现层 (Client)                                              │
│  消费 events/snapshots，按 event.type 映射到动画/音效/飘字     │
│  Kind/Tier 映射到图标、颜色、描述 key                           │
└─────────────────────────────────────────────────────────────┘
```

---

## 三、配置驱动：单一数据源

### 3.1 品阶 (Tier)

- **定义位置**：集中常量或配置表，例如 `shared/constants.ts` 或 `server/game/config/tiers.ts`。
- **内容**：id、数值倍率、可选显示用 key（客户端用 key 做多语言/颜色）。

```typescript
// 单一数据源，新增品阶只改此处
const TIER_CONFIG: Record<TierId, { multiplier: number; sortOrder: number }> = {
  bronze:   { multiplier: 1.0,  sortOrder: 0 },
  silver:   { multiplier: 1.5,  sortOrder: 1 },
  gold:     { multiplier: 2.2,  sortOrder: 2 },
  diamond:  { multiplier: 3.0,  sortOrder: 3 },
  legendary: { multiplier: 4.0, sortOrder: 4 },
};
type TierId = keyof typeof TIER_CONFIG;
```

- **扩展**：加新品阶 = 加一行配置；战斗/商店等统一从 `TIER_CONFIG` 读倍率，不写死字符串。

### 3.2 类别 (Kind)

- **定义位置**：`shared` 或 `server/game/config/kinds.ts`，一维列表或分组均可。
- **用途**：被动条件、商店/掉落过滤、描述 key。不在引擎里写死 kind 名。

```typescript
// 所有合法 Kind 的集合，用于校验与遍历
const KIND_IDS = [
  'weapon', 'apparel', 'aquatic', 'core', 'dinosaur', 'dragon',
  'drone', 'food', 'loot', 'potion', 'tool', 'property', 'ray',
  'relic', 'tech', 'vehicle', 'material', 'ammo', 'toy', 'companion', 'flight',
  'poison', 'burn', 'freeze', 'shield',  // 特性类
  'small', 'medium', 'large',            // 体积类
] as const;
type KindId = typeof KIND_IDS[number];
```

- **扩展**：新 Kind = 在 `KIND_IDS` 和配置里增加；被动逻辑通过「条件函数 + 注册」判断 kind，不 if (kind === 'dragon') 散落各处。

### 3.3 端口类型 (Port Type)

- **定义位置**：与 Tier/Kind 同级，例如 `server/game/config/portTypes.ts`。
- **内容**：端口类型 id、分类(output/operational/defense)、是否需要对目标、默认 targetRule 等。用于校验配置与驱动 UI 显示。

```typescript
const PORT_TYPE_CONFIG: Record<PortTypeId, {
  category: 'output' | 'operational' | 'defense';
  needsTarget: boolean;           // 是否依赖 targetRule 选目标
  defaultTargetRule?: TargetRuleKind;
}> = {
  damage:  { category: 'output',    needsTarget: false },
  poison:  { category: 'output',    needsTarget: false },
  burn:    { category: 'output',    needsTarget: false },
  destroy: { category: 'output',    needsTarget: true },
  haste:   { category: 'operational', needsTarget: true },
  charge:  { category: 'operational', needsTarget: true },
  slow:    { category: 'operational', needsTarget: true },
  freeze:  { category: 'operational', needsTarget: true },
  heal:    { category: 'defense',    needsTarget: false },
  shield:  { category: 'defense',    needsTarget: false },
};
type PortTypeId = keyof typeof PORT_TYPE_CONFIG;
```

- **扩展**：新效果 = 加一条 PortType 配置 + 在效果注册表里注册 handler（见下）。

### 3.4 卡牌配置 (ItemConfig)

- **结构**：完全数据化；效果只描述「类型 + 数值 + 目标规则」，不写逻辑。

```typescript
interface ItemConfig {
  itemId: string;
  name: string;
  description: string;
  kinds: KindId[];              // 从 KIND_IDS 取值
  size: 1 | 2 | 3;
  baseTier: TierId;             // 从 TIER_CONFIG 取值
  price: number;
  cooldown: number;             // 秒或回合，由引擎约定
  critRate?: number;            // 0–100，可选
  ports: {
    type: PortTypeId;           // 从 PORT_TYPE_CONFIG 取值
    value: number;
    targetRule?: TargetRuleKind; // 覆盖卡牌默认时使用
  }[];
  targetRule: TargetRuleKind;   // 卡牌默认目标规则
  tags?: string[];              // 兼容旧字段或扩展筛选
}
```

- **扩展**：新卡 = 新一条 ItemConfig；新效果类型 = 先有 PortType + EffectHandler，再在 ports 里引用 type。

### 3.5 目标规则 (TargetRule)

- **定义**：集中枚举 + 一个「解析函数」，输入 (targetRule, board, slotIndex, side)，输出「己方/敌方 + 槽位索引列表」。

```typescript
type TargetRule =
  | { kind: 'self' }
  | { kind: 'adjacent' }
  | { kind: 'leftmost' }
  | { kind: 'rightmost' }
  | { kind: 'all' }
  | { kind: 'position'; index: number };

function resolveTarget(
  rule: TargetRule,
  board: SlotItem[],
  selfSlotIndex: number,
  side: 'player' | 'enemy'
): { side: 'self' | 'opponent'; slotIndices: number[] } {
  // 纯函数，无副作用；新 targetRule 只在此处加分支
}
```

- **扩展**：新 targetRule = 在类型里加一种 kind + 在 `resolveTarget` 里加一种分支；效果层只消费「目标方 + 槽位列表」，不关心规则细节。

---

## 四、效果注册与执行（解耦核心循环）

### 4.1 战斗上下文 (BattleContext)

引擎内部维护一个 **只对效果层暴露的上下文**，不暴露「玩家/敌人」等业务对象，只暴露读写接口，便于测试和换实现。

```typescript
interface BattleContext {
  tick: number;
  elapsed: number;
  // 双方统一用 side 区分
  getHp(side: Side): number;
  setHp(side: Side, value: number): void;
  getMaxHp(side: Side): number;
  getShield(side: Side): number;
  setShield(side: Side, value: number): void;
  getPoison(side: Side): number;
  addPoison(side: Side, delta: number): void;
  getBurn(side: Side): number;
  addBurn(side: Side, delta: number): void;
  // 卡牌状态（按 side + slotIndex）
  getCardState(side: Side, slotIndex: number): CardRuntimeState;
  setCardState(side: Side, slotIndex: number, state: Partial<CardRuntimeState>): void;
  removeCard(side: Side, slotIndex: number): void;  // 摧毁
  getBoard(side: Side): SlotItem[];
  // 事件发射（引擎内部调用，handler 不直接写 UI）
  emit(event: BattleEvent): void;
}
type Side = 'player' | 'enemy';
```

- 效果 handler 只接收 `(ctx, value, sourceSide, sourceSlotIndex, targetSide, targetSlotIndices)`，不依赖具体 Combatant 结构。

### 4.2 效果处理器 (EffectHandler) 注册

- 每个端口类型对应一个 handler；**新增效果 = 新写一个 handler + 注册**，不动大循环。

```typescript
type EffectHandler = (
  ctx: BattleContext,
  value: number,
  source: { side: Side; slotIndex: number },
  target: { side: Side; slotIndices: number[] }
) => void;

const effectRegistry = new Map<PortTypeId, EffectHandler>();

// 注册示例
effectRegistry.set('damage', (ctx, value, _src, tgt) => {
  const shield = ctx.getShield(tgt.side);
  const real = Math.max(0, value - shield);
  ctx.setShield(tgt.side, Math.max(0, shield - value));
  ctx.setHp(tgt.side, ctx.getHp(tgt.side) - real);
  ctx.emit({ type: 'damage', value: real, targetSide: tgt.side, ... });
});
effectRegistry.set('haste', (ctx, value, _src, tgt) => {
  for (const idx of tgt.slotIndices) {
    const s = ctx.getCardState(tgt.side, idx);
    ctx.setCardState(tgt.side, idx, { hasteRemain: (s.hasteRemain ?? 0) + value });
  }
  ctx.emit({ type: 'haste', value, targetSide: tgt.side, targetSlotIndices: tgt.slotIndices });
});
// ... 其余 port 类型同理
```

- 引擎在「触发某张卡某 port」时：查 `effectRegistry.get(port.type)`，若存在则调用；不存在则打日志或忽略，不崩溃。
- **扩展**：新 port 类型在配置里声明，再写一个 EffectHandler 并 `effectRegistry.set(type, handler)`。

### 4.3 目标解析与效果调用统一入口

- 引擎在每 tick 触发某张卡时：
  1. 取该卡 `ports` 列表；
  2. 对每个 port：用卡牌或 port 上的 `targetRule` 调用 `resolveTarget` 得到 `{ side, slotIndices }`；
  3. 用品阶倍率（和暴击）算出 `value`；
  4. `effectRegistry.get(port.type)?.(ctx, value, source, target)`；
  5. 所有状态变更经 `ctx` 完成，事件经 `ctx.emit` 发出。

这样，**增加新效果、新 targetRule 都不改引擎主循环**，只改配置 + 注册表。

---

## 五、Kind 与被动效果（可选扩展）

- Kind 不参与「谁打谁」的底层逻辑，只参与 **数值修正** 和 **条件触发**。
- 设计成「条件 + 修正函数」的注册表，避免在引擎里写大量 if (hasKind('dragon'))。

```typescript
type KindCondition = (board: SlotItem[], itemConfig: ItemConfig) => boolean;
type KindModifier = (value: number, context: { board: SlotItem[]; slotIndex: number }) => number;

// 例：己方每有一张 dragon，灼烧类 port 的 value +2
registerKindPassive('dragon', {
  when: (board, cfg) => cfg.ports.some(p => p.type === 'burn'),
  modify: (value, { board }) => value + 2 * countKindsOnBoard(board, ['dragon']),
});
```

- 引擎在「计算 port value」时，先取基础 value，再按「当前卡 + 己方棋盘」跑一遍 Kind 被动注册表，得到最终 value，再交给 EffectHandler。这样 **新 Kind 或新被动 = 新注册一条**，不散落 if。

---

## 六、战斗引擎输出（与客户端契约）

### 6.1 只输出结构化数据

- 引擎不输出「播放某动画」「某资源路径」，只输出：
  - **BattleResult**：胜负、剩余 HP、奖励等；
  - **BattleEvent[]**：按时间顺序的「发生了什么」；
  - **BattleSnapshot[]**（可选）：关键 tick 的双方 HP/护盾/毒/烧等，用于 UI 拉条或回放。

### 6.2 事件结构（与表现解耦）

- 事件用 **type + payload**，客户端根据 type 决定如何表现。

```typescript
type BattleEvent =
  | { type: 'damage'; value: number; targetSide: Side; crit?: boolean }
  | { type: 'heal'; value: number; targetSide: Side }
  | { type: 'shield'; value: number; targetSide: Side }
  | { type: 'poison'; value: number; targetSide: Side }
  | { type: 'burn'; value: number; targetSide: Side }
  | { type: 'haste'; value: number; targetSide: Side; targetSlotIndices: number[] }
  | { type: 'slow'; value: number; targetSide: Side; targetSlotIndices: number[] }
  | { type: 'freeze'; value: number; targetSide: Side; targetSlotIndices: number[] }
  | { type: 'charge'; value: number; targetSide: Side; targetSlotIndices: number[] }
  | { type: 'destroy'; targetSide: Side; targetSlotIndex: number }
  | { type: 'card_trigger'; side: Side; slotIndex: number; portType: PortTypeId }
  | { type: 'overtime'; playerDamage: number; enemyDamage: number }
  | { type: 'battle_end'; winner: Side };
```

- 客户端维护 `Map<BattleEvent['type'], (payload) => void>`，负责播动画、飘字、音效；**新增事件类型只加联合类型 + 客户端一个 case**，引擎侧多数情况只是 emit 新 shape。

### 6.3 快照结构

- 快照仅包含「可序列化的数值状态」，便于回放与调试。

```typescript
interface BattleSnapshot {
  tick: number;
  player: { hp: number; maxHp: number; shield: number; poison: number; burn: number };
  enemy:  { hp: number; maxHp: number; shield: number; poison: number; burn: number };
  playerCards: { slotIndex: number; currentCooldown: number; hasteRemain: number; slowRemain: number; freezeRemain: number }[];
  enemyCards:  { slotIndex: number; currentCooldown: number; hasteRemain: number; slowRemain: number; freezeRemain: number }[];
}
```

- 客户端用 snapshots 驱动 HP 条、护盾/毒/烧显示、卡牌充能条等，**不依赖引擎内部类或 UI 类型**。

---

## 七、客户端表现映射（解耦方式）

- 所有「表现」集中在客户端少量映射表或工厂里：
  - **PortTypeId / BattleEvent.type** → 动画名、飘字颜色、音效 key；
  - **KindId** → 图标、描述 key、筛选标签；
  - **TierId** → 颜色、边框、描述 key。
- 服务端不下发资源路径或动画名；可下发 **i18n key**（如 `effect.damage`、`kind.dragon`），由客户端查表渲染。
- 这样 **换皮、多语言、新效果表现** 都只在客户端扩展映射，不动服务端与战斗逻辑。

---

## 八、目录与职责建议

```
shared/
  constants.ts        # 品阶、Kind 等常量
  types/
    game.ts           # SlotItem, Combatant, BattleResult
    config.ts         # ItemConfig, MonsterConfig, TargetRule
    battle.ts         # BattleEvent, BattleSnapshot（与客户端契约）

server/
  game/
    config/
      tiers.ts        # TIER_CONFIG
      kinds.ts        # KIND_IDS
      portTypes.ts    # PORT_TYPE_CONFIG
      items.ts        # ItemConfig[]
      monsters.ts
    battle/
      context.ts      # BattleContext 实现
      resolveTarget.ts
      effectHandlers/
        index.ts      # 注册所有 handler
        damage.ts
        haste.ts
        ...
      engine.ts       # 主循环：tick、充能、触发、DoT、overtime、emit
```

- **加新效果**：在 `effectHandlers/` 加一个文件并到 `index.ts` 注册；必要时在 `portTypes.ts` 和 `shared/types` 里加类型。
- **加新 Kind**：在 `kinds.ts` 和 ItemConfig 的 `kinds` 里加；若有被动，在 Kind 被动注册表加一条。
- **加新卡**：只在 `config/items.ts`（或数据源）加一条 ItemConfig。

---

## 九、扩展清单速查

| 需求 | 主要改动点 | 不改动 |
|------|------------|--------|
| 新增一种卡牌效果 (port) | PortType 配置 + EffectHandler 实现 + 注册 | 引擎主循环、客户端现有映射 |
| 新增目标规则 | TargetRule 类型 + resolveTarget 分支 | 效果 handler、卡牌配置 |
| 新增品阶 | TIER_CONFIG 一行 | 引擎逻辑、客户端只加映射 |
| 新增 Kind | KIND_IDS + 配置/被动注册 | 引擎核心、效果 handler |
| 新增卡牌 | ItemConfig 一条 | 引擎、注册表 |
| 新效果的表现 | 客户端 event.type → 动画/飘字 | 服务端、战斗逻辑 |
| 新 Kind/Tier 的 UI | 客户端 Kind/Tier → 图标/颜色 | 服务端、战斗逻辑 |

这样，**复杂内容集中在配置与注册层，战斗引擎只做「按配置驱动 + 发事件」**，客户端只做「按事件和快照驱动表现」，扩展时互不牵制，复杂度可控。
